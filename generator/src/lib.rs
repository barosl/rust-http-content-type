/*

# Usage

```
pub fn get_content_type(ext: &str) -> Option<MediaType> {
    match_mimes!(ext, "http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types")
}
```

# The generated code will look like the following:

```
match ext {
    "ez" => Some(MediaType {
        type_: "application".to_string(),
        subtype: "andrew-inset".to_string(),
        parameters: vec![]
    }),
    "aw" => Some(MediaType {
        type_: "application".to_string(),
        subtype: "applixware".to_string(),
        parameters: vec![]
    }),
    ...
    _    => None
}
```
*/

#![crate_name = "generator"]
#![crate_type = "dylib"]
#![license = "MIT"]

#![feature(macro_rules, plugin_registrar, phase)]

extern crate http;
extern crate regex;
#[phase(plugin)] extern crate regex_macros;
extern crate rustc;
extern crate syntax;
extern crate url;

use rustc::plugin::Registry;
use syntax::{ast, codemap};
use syntax::ast::{CookedStr, LitStr};
use syntax::codemap::Spanned;
use syntax::ext::base::{DummyResult, ExtCtxt, MacExpr, MacResult};
use syntax::ext::build::AstBuilder;
use syntax::parse::token::{mod, COMMA, IDENT, LIT_STR};
use syntax::ptr::P;

use download::{download_mimes, parse_mimes};

mod download;

#[plugin_registrar]
pub fn plugin_registrar(reg: &mut Registry) {
    reg.register_macro("match_mimes", expand);
}

// See http://doc.rust-lang.org/nightly/syntax/ext/build/trait.AstBuilder.html for documentation
// over the functions used to build the AST.
fn expand(cx: &mut ExtCtxt, sp: codemap::Span, tts: &[ast::TokenTree]) -> Box<MacResult + 'static> {
    // Try to parse the arguments of the macro
    let (id, url) = match parse_arguments(sp, tts) {
        Ok(x) => { x }
        Err((span, msg)) => {
            cx.span_err(span, msg);
            return DummyResult::any(span);
        }
    };

    // Download the mimes from the given url
    let mime_text = match download_mimes(url.node.as_slice()) {
        Ok(v)  => v,
        Err(m) => {
            cx.span_err(url.span, m.as_slice());
            return DummyResult::any(url.span);
        }
    };

    // Parse the mimes using regular expressions
    let parsed_mimes = match parse_mimes(mime_text.as_slice()) {
        Ok(v)  => v,
        Err(m) => {
            cx.span_err(url.span, m.as_slice());
            return DummyResult::any(url.span);
        }
    };

    // Create an expression for the variable we are matching on
    let match_arg = cx.expr_ident(id.span, id.node);

    // Create an expression for the arms of the match
    let mut match_arms: Vec<_> = parsed_mimes.into_iter().map(|(e, t, s)| generate_arm(cx, sp, e, t, s)).collect();
    match_arms.push(generate_last_arm(cx, sp));

    // Create an expression for the match, based on the previous two expressions
    let match_ = cx.expr_match(sp, match_arg, match_arms);

    // MacExpr represents an expression generated by a macro
    MacExpr::new(match_)
}

// Returns an `Arm` matching the content of `ext` and returning a `Some(MediaType)`
// e.g. "foo" => Some(MediaType { type_: "bar".to_string(), subtype: "baz".to_string(), parameters: vec![] })
fn generate_arm(cx: &ExtCtxt, sp: codemap::Span, ext: &str, type_: &str, subtype: &str) -> ast::Arm {
    let media_type = generate_media_type(cx, sp, type_, subtype);
    let arm_expr = cx.expr_some(sp, media_type);

    // We need to turn `ext` into a string literal, to be able to use it as a pattern
    let literal = str_to_lit(cx, sp, ext);
    let pattern = cx.pat_lit(sp, literal);

    cx.arm(sp, vec![pattern], arm_expr)
}

// Returns an `Arm` matching the wildcard and returning `None`
fn generate_last_arm(cx: &ExtCtxt, sp: codemap::Span) -> ast::Arm {
    let pattern = cx.pat_wild(sp);
    let none = cx.expr_none(sp);
    cx.arm(sp, vec![pattern], none)
}

// Returns an expression corresponding to the declaration of a new `MediaType` object
// See comment to `generate_arm` for details
fn generate_media_type(cx: &ExtCtxt, sp: codemap::Span, type_: &str, subtype: &str) -> P<ast::Expr> {
    // We need to call .to_string() on the value
    let call_to_string = |expr_| cx.expr_method_call(sp, expr_, token::str_to_ident("to_string"), vec![]);
    let get_field = |name, value| cx.field_imm(sp, token::str_to_ident(name), call_to_string(str_to_lit(cx, sp, value)));

    let fields = vec![get_field("type_", type_),
                      get_field("subtype", subtype),
                      cx.field_imm(sp, token::str_to_ident("parameters"), cx.expr_vec_ng(sp))];

    let struct_name = cx.path_ident(sp, token::str_to_ident("MediaType"));

    cx.expr_struct(sp, struct_name, fields)
}

// Transforms a `&str` into a string literal
// This is an utility function
fn str_to_lit(cx: &ExtCtxt, sp: codemap::Span, s: &str) -> P<ast::Expr> {
    let interned = token::intern_and_get_ident(s);
    let lit_ = LitStr(interned, CookedStr);
    cx.expr_lit(sp, lit_)
}

// We expext the arguments to be `$ident, $expr`, where `$expr` is a string literal
// If parsing succeeds, this will return the ident and the string literal
// Otherwise, it will return a span and an error message
fn parse_arguments(main_sp: codemap::Span, tts: &[ast::TokenTree])
    -> Result<(Spanned<ast::Ident>, Spanned<String>), (codemap::Span, &'static str)>
    {
    // We expect an identifier, a comma and a string literal
    if tts.len() != 3 {
        return Err((main_sp, "Wrong number of arguments"));
    }

    // The identifier
    let identifier = match tts[0] {
        ast::TTTok(sp, IDENT(i, _)) => Spanned { node: i.clone(), span: sp },
        _                           => return Err((main_sp, "Identifier expected"))
    };

    // The comma
    match tts[1] {
        ast::TTTok(_, COMMA)  => { }
        _                     => return Err((main_sp, "Comma expected"))
    }

    // The string literal
    let string = match tts[2] {
        ast::TTTok(sp, LIT_STR(content))
            => Spanned { node: content.as_str().to_string(), span: sp },
        _   => return Err((main_sp, "String literal expected"))
    };

    Ok((identifier, string))
}
